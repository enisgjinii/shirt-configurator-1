/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useEffect, useRef, useState } from "react";
import { useGLTF } from "@react-three/drei";
import { useFrame, useThree } from "@react-three/fiber";
import * as THREE from "three";
import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader";
import { DRACOLoader } from "three/examples/jsm/loaders/DRACOLoader";
import { OBJLoader } from "three/examples/jsm/loaders/OBJLoader";
import { STLLoader } from "three/examples/jsm/loaders/STLLoader";
import { GLTFExporter } from "three/examples/jsm/exporters/GLTFExporter";
import { OBJExporter } from "three/examples/jsm/exporters/OBJExporter";
import { STLExporter } from "three/examples/jsm/exporters/STLExporter";
import { Card, CardContent, CardTitle } from "./ui/card";
import { Button } from "./ui/button";
import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";

export default function Shirt({ modelUrl, onTextureCanvas, onUvMapUrl }) {
  const [gltf, setGltf] = useState(null);
  const [mainMesh, setMainMesh] = useState(null);
  const [mainMaterial, setMainMaterial] = useState(null);
  const [texture, setTexture] = useState();
  const [canvas, setCanvas] = useState();
  const [uvMapUrl, setUvMapUrl] = useState("");
  const [shirtColor, setShirtColor] = useState("#ffffff");
  const [image, setImage] = useState(null);
  const [text, setText] = useState("");
  const [textColor, setTextColor] = useState("#000000");
  const [placementMode, setPlacementMode] = useState(null); // 'image' | 'text' | null
  const [placementData, setPlacementData] = useState(null); // image or text data
  const [placementUV, setPlacementUV] = useState(null); // { u, v }
  const { gl, scene, camera } = useThree();
  const canvasRef = useRef();
  const controlsRef = useRef();

  // Listen for sidebar changes (color, image, text, textColor, export)
  useEffect(() => {
    function handleSidebar(e) {
      if (e.detail) {
        if (e.detail.color) setShirtColor(e.detail.color);
        if (e.detail.image) setImage(e.detail.image);
        if (e.detail.text !== undefined) setText(e.detail.text);
        if (e.detail.textColor) setTextColor(e.detail.textColor);
        if (e.detail.format) handleExport(e.detail.format);
      }
    }
    window.addEventListener("shirt-controls", handleSidebar);
    window.addEventListener("shirt-export", handleSidebar);
    return () => {
      window.removeEventListener("shirt-controls", handleSidebar);
      window.removeEventListener("shirt-export", handleSidebar);
    };
  }, []);

  // Listen for placement mode
  useEffect(() => {
    function handlePlacement(e) {
      if (e.detail) {
        setPlacementMode(e.detail.type);
        setPlacementData(e.detail.data);
        setPlacementUV(null);
      }
    }
    window.addEventListener('shirt-placement', handlePlacement);
    return () => window.removeEventListener('shirt-placement', handlePlacement);
  }, []);

  // Load model dynamically (from prop)
  useEffect(() => {
    let loader;
    if (modelUrl.endsWith(".glb") || modelUrl.endsWith(".gltf")) {
      loader = new GLTFLoader();
      // DRACO support
      const dracoLoader = new DRACOLoader();
      dracoLoader.setDecoderPath("https://www.gstatic.com/draco/v1/decoders/");
      loader.setDRACOLoader(dracoLoader);
      loader.load(modelUrl, (gltf) => {
        setGltf(gltf);
        // Find main mesh/material
        let mesh = null, mat = null;
        gltf.scene.traverse((child) => {
          if (child.isMesh && !mesh) {
            mesh = child;
            mat = child.material;
          }
        });
        setMainMesh(mesh);
        setMainMaterial(mat);
        // Extract texture or create blank
        let tex = mat && mat.map ? mat.map : null;
        if (!tex) {
          // Create blank texture
          const c = document.createElement("canvas");
          c.width = 1024;
          c.height = 1024;
          const ctx = c.getContext("2d");
          ctx.fillStyle = shirtColor;
          ctx.fillRect(0, 0, c.width, c.height);
          tex = new THREE.CanvasTexture(c);
        }
        setTexture(tex);
        // UV map preview
        if (mesh && mesh.geometry && mesh.geometry.attributes.uv) {
          const uvCanvas = document.createElement("canvas");
          uvCanvas.width = 1024;
          uvCanvas.height = 1024;
          const uvCtx = uvCanvas.getContext("2d");
          uvCtx.fillStyle = "#fff";
          uvCtx.fillRect(0, 0, 1024, 1024);
          uvCtx.strokeStyle = "#000";
          uvCtx.lineWidth = 1;
          const pos = mesh.geometry.attributes.position;
          const uv = mesh.geometry.attributes.uv;
          for (let i = 0; i < uv.count; i += 3) {
            uvCtx.beginPath();
            for (let j = 0; j < 3; j++) {
              const u = uv.getX(i + j) * 1024;
              const v = (1 - uv.getY(i + j)) * 1024;
              if (j === 0) uvCtx.moveTo(u, v);
              else uvCtx.lineTo(u, v);
            }
            uvCtx.closePath();
            uvCtx.stroke();
          }
          setUvMapUrl(uvCanvas.toDataURL("image/png"));
        }
      });
    } else if (modelUrl.endsWith(".obj")) {
      loader = new OBJLoader();
      loader.load(modelUrl, (obj) => {
        setGltf({ scene: obj });
        let mesh = null, mat = null;
        obj.traverse((child) => {
          if (child.isMesh && !mesh) {
            mesh = child;
            mat = child.material;
          }
        });
        setMainMesh(mesh);
        setMainMaterial(mat);
        setTexture(null); // OBJ rarely has texture
        setUvMapUrl("");
      });
    } else if (modelUrl.endsWith(".stl")) {
      loader = new STLLoader();
      loader.load(modelUrl, (geometry) => {
        const mat = new THREE.MeshStandardMaterial({ color: shirtColor });
        const mesh = new THREE.Mesh(geometry, mat);
        setGltf({ scene: mesh });
        setMainMesh(mesh);
        setMainMaterial(mat);
        setTexture(null);
        setUvMapUrl("");
      });
    }
  }, [modelUrl]);

  // Compose the texture on the hidden canvas
  useEffect(() => {
    if (!mainMaterial) return;
    let c = document.createElement("canvas");
    c.width = 1024;
    c.height = 1024;
    const ctx = c.getContext("2d");
    ctx.clearRect(0, 0, c.width, c.height);
    ctx.fillStyle = shirtColor;
    ctx.fillRect(0, 0, c.width, c.height);
    if (image) {
      const img = new window.Image();
      img.onload = () => {
        ctx.drawImage(img, 200, 200, 624, 624);
        updateTexture(c);
      };
      img.src = image;
    }
    if (text) {
      ctx.font = "bold 96px sans-serif";
      ctx.fillStyle = textColor;
      ctx.textAlign = "center";
      ctx.fillText(text, c.width / 2, c.height - 100);
    }
    updateTexture(c);
    setCanvas(c);
    // eslint-disable-next-line
  }, [mainMaterial, shirtColor, image, text, textColor]);

  // Raycast for placement
  useEffect(() => {
    if (!placementMode || !mainMesh) return;
    const handlePointerDown = (event) => {
      // Get mouse position in normalized device coordinates
      const rect = gl.domElement.getBoundingClientRect();
      const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
      const mouse = new THREE.Vector2(x, y);
      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObject(mainMesh, true);
      if (intersects.length > 0) {
        const uv = intersects[0].uv;
        setPlacementUV({ u: uv.x, v: uv.y });
      }
    };
    gl.domElement.addEventListener('pointerdown', handlePointerDown);
    return () => gl.domElement.removeEventListener('pointerdown', handlePointerDown);
  }, [placementMode, mainMesh, gl, camera]);

  // When placementUV is set, bake image/text at that UV
  useEffect(() => {
    if (!placementMode || !placementUV || !mainMaterial) return;
    // Compose on a new canvas
    let c = document.createElement("canvas");
    c.width = 1024;
    c.height = 1024;
    const ctx = c.getContext("2d");
    ctx.clearRect(0, 0, c.width, c.height);
    ctx.fillStyle = shirtColor;
    ctx.fillRect(0, 0, c.width, c.height);
    // Draw previous image/text if any
    if (image && placementMode !== 'image') {
      ctx.drawImage(awaitImage(image), 200, 200, 624, 624);
    }
    if (text && placementMode !== 'text') {
      ctx.font = "bold 96px sans-serif";
      ctx.fillStyle = textColor;
      ctx.textAlign = "center";
      ctx.fillText(text, c.width / 2, c.height - 100);
    }
    // Draw new placement
    if (placementMode === 'image' && placementData) {
      const img = awaitImage(placementData);
      // Place at UV
      const px = placementUV.u * c.width;
      const py = (1 - placementUV.v) * c.height;
      ctx.drawImage(img, px - 100, py - 100, 200, 200);
    }
    if (placementMode === 'text' && placementData) {
      ctx.font = "bold 48px sans-serif";
      ctx.fillStyle = placementData.color || "#000";
      ctx.textAlign = "center";
      const px = placementUV.u * c.width;
      const py = (1 - placementUV.v) * c.height;
      ctx.fillText(placementData.text, px, py);
    }
    updateTexture(c);
    setCanvas(c);
    setPlacementMode(null);
    setPlacementData(null);
    setPlacementUV(null);
    // eslint-disable-next-line
  }, [placementUV]);

  // Helper to load image synchronously
  function awaitImage(src) {
    const img = new window.Image();
    img.src = src;
    return img;
  }

  function updateTexture(c) {
    if (!mainMaterial) return;
    const tex = new THREE.CanvasTexture(c);
    tex.needsUpdate = true;
    tex.flipY = false;
    tex.encoding = THREE.sRGBEncoding;
    tex.anisotropy = 16;
    tex.wrapS = THREE.RepeatWrapping;
    setTexture(tex);
    mainMaterial.map = tex;
    mainMaterial.needsUpdate = true;
    mainMaterial.side = THREE.DoubleSide;
  }

  useFrame(() => {
    if (texture) texture.needsUpdate = true;
  });

  // Export logic (same as before)
  function handleExport(format) {
    if (!mainMesh) return;
    if (format === "gltf" || format === "glb") {
      const exporter = new GLTFExporter();
      exporter.parse(
        mainMesh,
        (result) => {
          let output, blob, filename;
          if (format === "gltf") {
            output = JSON.stringify(result, null, 2);
            blob = new Blob([output], { type: "application/json" });
            filename = "model.gltf";
          } else {
            blob = new Blob([result], { type: "application/octet-stream" });
            filename = "model.glb";
          }
          downloadBlob(blob, filename);
        },
        { binary: format === "glb", embedImages: true }
      );
    } else if (format === "obj") {
      const exporter = new OBJExporter();
      const result = exporter.parse(mainMesh);
      const blob = new Blob([result], { type: "text/plain" });
      downloadBlob(blob, "model.obj");
    } else if (format === "stl") {
      const exporter = new STLExporter();
      const result = exporter.parse(mainMesh);
      const blob = new Blob([result], { type: "text/plain" });
      downloadBlob(blob, "model.stl");
    } else if (format === "png") {
      gl.render(scene, camera);
      const dataURL = gl.domElement.toDataURL("image/png");
      const a = document.createElement("a");
      a.href = dataURL;
      a.download = "model.png";
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    }
  }
  function downloadBlob(blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }

  // Call onTextureCanvas when canvas changes (for preview in parent)
  useEffect(() => {
    if (onTextureCanvas && canvas) onTextureCanvas(canvas);
  }, [canvas, onTextureCanvas]);
  // Call onUvMapUrl when uvMapUrl changes
  useEffect(() => {
    if (onUvMapUrl && uvMapUrl) onUvMapUrl(uvMapUrl);
  }, [uvMapUrl, onUvMapUrl]);

  // Fit camera to model after loading
  function fitCameraToObject(object, camera, controls, offset = 1.25) {
    const box = new THREE.Box3().setFromObject(object);
    const size = box.getSize(new THREE.Vector3());
    const center = box.getCenter(new THREE.Vector3());
    const maxDim = Math.max(size.x, size.y, size.z);
    const fov = camera.fov * (Math.PI / 180);
    let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2)) * offset;
    camera.position.set(center.x, center.y, cameraZ + center.z);
    camera.lookAt(center);
    if (controls) {
      controls.target.copy(center);
      controls.update();
    }
  }

  useEffect(() => {
    if (gltf && camera) {
      fitCameraToObject(gltf.scene, camera, controlsRef.current);
    }
  }, [gltf, camera]);

  // Only return 3D objects
  return gltf ? <primitive object={gltf.scene} dispose={null} /> : null;
}

useGLTF.preload("/models/uvshirt.glb"); 